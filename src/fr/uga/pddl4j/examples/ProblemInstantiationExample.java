package fr.uga.pddl4j.examples;

import fr.uga.pddl4j.parser.DefaultParsedProblem;
import fr.uga.pddl4j.parser.ErrorManager;
import fr.uga.pddl4j.parser.Message;
import fr.uga.pddl4j.parser.Parser;
import fr.uga.pddl4j.problem.DefaultProblem;
import fr.uga.pddl4j.problem.Problem;
import fr.uga.pddl4j.problem.operator.Action;
import fr.uga.pddl4j.problem.Fluent;
import fr.uga.pddl4j.problem.InitialState;
import fr.uga.pddl4j.problem.operator.Condition;
import fr.uga.pddl4j.util.BitVector;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.IOException;

import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;

import java.io.*;
import java.util.*;
/**
 * The class is an example class. It shows how to use the library to create to ground planning problem.
 *
 * @author D. Pellier
 * @version 4.0 - 06.12.2021
 */
public class ProblemInstantiationExample {

    /**
     * The main method the class. The first argument must be the path to the PDDL domain description and the second
     * argument the path to the PDDL problem description.
     *
     * @param args the command line arguments.
     */
    public static void main(final String[] args) {

        // Checks the number of arguments from the command line
        if (args.length != 2) {
            System.out.println("Invalid command line");
            return;
        }

        try {
            // Creates an instance of the PDDL parser
            final Parser parser = new Parser();
            // Parses the domain and the problem files.
            final DefaultParsedProblem parsedProblem = parser.parse(args[0], args[1]);
            // Gets the error manager of the parser
            final ErrorManager errorManager = parser.getErrorManager();
            // Checks if the error manager contains errors
            if (!errorManager.isEmpty()) {
                // Prints the errors
                for (Message m : errorManager.getMessages()) {
                    System.out.println(m.toString());
                }
            } else {
                // Prints that the domain and the problem were successfully parsed
                System.out.print("\nparsing domain file \"" + args[0] + "\" done successfully");
                System.out.print("\nparsing problem file \"" + args[1] + "\" done successfully\n\n");
                // Create a problem
                final Problem problem = new DefaultProblem(parsedProblem);
                // Instantiate the planning problem
                problem.instantiate();
                // Print the list of actions of the instantiated problem
                for (Action a : problem.getActions()) {
                    System.out.println(problem.toString(a));
					System.out.println(a);
                }
				System.out.println(problem.getActions());
				
				for (Fluent g : problem.getFluents()) {
                    System.out.println(problem.toString(g));
					System.out.println(g);
                }
				List<Fluent> flu = problem.getFluents();
				int total_fluents = flu.size();
				System.out.println(flu.size());
				InitialState init = problem.getInitialState();
				System.out.println(init);
				System.out.println(init. getPositiveFluents());
				Condition goal = problem.getGoal();
				System.out.println(goal);
				System.out.println(goal.getNumericConstraints());
				int m = 30;
				String filePath = "cnf";
				try {
					int nb_lines = 0;
					try (PrintWriter writer = new PrintWriter(new FileWriter(filePath))) {
						
						writer.println("c This is a CNF file generated by EncoderDimacs");
						writer.println("p cnf "+total_fluents*m+" 2");
						
						BitVector posflu = init.getPositiveFluents();
						BitVector negflu = init.getNegativeFluents();
						BitVector posflu_goal = goal.getPositiveFluents();
						long[] posf = posflu.toLongArray();
						System.out.println(posflu.length());
						System.out.println(negflu.length());
						System.out.println(total_fluents);
						int n = posflu.length();
						for (int i = 1; i < total_fluents+1; i++) {
							if (i <= n){
								if (posflu.get(i)){
									writer.println(i+" "+0);
									nb_lines += 1;
								}
								else{
									writer.println(-i+" "+0);
									nb_lines = nb_lines+1;
								}
							}
							else{
								writer.println(-i+" "+0);
								nb_lines = nb_lines+1;
							}
						}


						int n2 = posflu_goal.length();
						System.out.println(posflu_goal.length());
						for (int i = 1; i < total_fluents+1; i++) {
							if (i <= n2-1){
								if (posflu_goal.get(i)){
									writer.println((i+total_fluents*(m-1))+" "+0);
									nb_lines = nb_lines+1;
								}
								else{
									writer.println((-i-total_fluents*(m-1))+" "+0);
									nb_lines = nb_lines+1;
								}
							}
							else{
								writer.println((-i-total_fluents*(m-1))+" "+0);
									nb_lines = nb_lines+1;
							}
						}
						
						writer.flush();
					}
					
					
					List<String> lines = new ArrayList<>();
					try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
						String line;
						while ((line = reader.readLine()) != null) {
							lines.add(line);
						}
					}

					// Step 3: Modify the first line
					if (lines.size() > 1) {
						String header = lines.get(1);
						String[] parts = header.split(" ");
						if (parts.length > 3) {
							parts[3] = Integer.toString(nb_lines);  // Change the "3" to "100"
							lines.set(1, String.join(" ", parts));
						}
					}

					// Step 4: Write the modified content back to the file
					try (PrintWriter writer = new PrintWriter(new FileWriter(filePath))) {
						for (String line : lines) {
							writer.println(line);
						}
					}
				} catch (IOException e) {
					e.printStackTrace();
				}
			
				
				
				
            }
            // This exception could happen if the domain or the problem does not exist
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}